---
title: Using map, reduce and filter with examples in Typescript and Javascript
abstract: Explaining map, reduce and filter with examples both in Javascript and Typescript
publishedOn: '2023-08-30T08:00:00-0200'
---

_**Note:** This article was generated by ChatGPT. It's basically a modern take on Lorem Ipsum._

Before we dive into the specific methods, let’s talk about the difference between TypeScript and JavaScript. TypeScript is a superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code. The main difference between the two languages is that TypeScript is a statically-typed language, while JavaScript is a dynamically-typed language. This means that in TypeScript, you can specify the types of variables, function parameters, and return values, while in JavaScript, the types are determined at runtime.

Here’s an example that shows how you can use types in TypeScript:

## TypeScript vs Javascript

```ts
function add(a: number, b: number): number {
    return a + b;
}

const sum = add(1, 2); // 3
```

In this example, we have a function add that takes two parameters a and b, both of type number, and returns a value of type number. When we call the add function with arguments 1 and 2, the TypeScript compiler checks that the arguments are of the correct type and that the return value is also of the correct type.

Here’s the same example in JavaScript:

```js
function add(a, b) {
    return a + b;
}

const sum = add(1, 2); // 3
```

In the JavaScript version, we don’t specify the types of the parameters or the return value. The types are determined at runtime when the function is called.

Now let’s move on to the specific array methods. We’ll start with the map method.

## Map

The map method creates a new array with the results of calling a provided function on every element in the calling array. Think of it like a factory assembly line: each item in the array goes through the assembly line (the provided function) and is transformed into something new.

Here’s an example in TypeScript:

```ts
const numbers = [1, 2, 3, 4];
const doubledNumbers = numbers.map((num: number) => num * 2);
console.log(doubledNumbers); // [2, 4, 6, 8]
```

In this example, we have an array of numbers [1, 2, 3, 4]. We use the map method to create a new array where each number is doubled. The provided function takes each number (num) and returns it multiplied by 2 (num * 2). The result is a new array [2, 4, 6, 8].

Here’s the same example in JavaScript:

```js
const numbers = [1, 2, 3, 4];
const doubledNumbers = numbers.map(function (num) {
    return num * 2;
});
console.log(doubledNumbers); // [2, 4, 6, 8]
```

The only difference between the TypeScript and JavaScript versions is that in TypeScript we specify the type of the function parameter (num: number) while in JavaScript we don’t.

## Reduce
The reduce method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value. Think of it like folding a piece of paper: you start with a large piece of paper (the array) and fold it repeatedly (the provided function) until you end up with a small folded piece of paper (the single value).

Here’s an example in TypeScript:

```ts
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((acc: number, num: number) => acc + num);
console.log(sum); // 10
```

In this example, we have an array of numbers [1, 2, 3, 4]. We use the reduce method to calculate the sum of all the numbers in the array. The provided function takes two arguments: the accumulator (acc) and the current number (num). The function returns the sum of the accumulator and the current number (acc + num). The result is a single value 10.

Here’s the same example in JavaScript:

```js
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce(function (acc,num) {
    return acc + num;
});
console.log(sum); //10
```

Again,the only difference between TypeScript and JavaScript versions is that in TypeScript we specify types for both accumulator(acc:number)and current number(num:number) while in javascript we don’t.

## Filter

The filter method creates a new array with all elements that pass test implemented by provided function.Think of it like sieve,you pour an array into sieve(the provided function),and only the elements that pass through the holes(pass the test) end up in new array.

Here’s an example in TypeScript:

```ts
const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter((num: number) => num % 2 === 0);
console.log(evenNumbers); // [2 ,4]
```

In this example we have an array of numbers [1 ,2 ,3 ,4]. We use filter method to create new array where only even numbers are present. The provided function takes each number(num) and returns true if number is even(num %2 ===0). The result is new array [2 ,4].

Here’s same example in javascript:

```js
const numbers = [1 ,2 ,3 ,4];
const evenNumbers = numbers.filter(function(num){
    return num %2 ===0;
});
console.log(evenNumbers); // [2 ,4]
```

The only difference between typescript and javascript version is that in typescript we specify type for current number(num:number) while in javascript we don’t.

The filter method can be used for more complex filtering as well. For example, you can use it to filter objects based on their properties:

```ts
interface Person {
    name: string;
    age: number;
}

const people: Person[] = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 35 },
];

const over30 = people.filter((person: Person) => person.age > 30);
console.log(over30); // [{ name: 'Charlie', age: 35 }]
```

In this example, we have an array of Person objects. We use the filter method to create a new array where only the people over the age of 30 are included. The provided function takes each Person object (person) and returns true if the person’s age is greater than 30 (person.age > 30). The result is a new array with only one Person object, { name: 'Charlie', age: 35 }.

## When not to use reduce

While the reduce method can be a powerful tool, it’s not always the best choice for every situation. In some cases, using other array methods like map, filter, or forEach can result in more readable and maintainable code.

For example, let’s say you want to calculate the sum of all even numbers in an array. You could use the reduce method like this:

```ts
const numbers = [1, 2, 3, 4];
const sumOfEvenNumbers = numbers.reduce((acc: number, num: number) => {
    if (num % 2 === 0) {
        return acc + num;
    } else {
        return acc;
    }
}, 0);
console.log(sumOfEvenNumbers); // 6
```

However, this code can be difficult to read and understand at first glance. A more readable approach would be to first use the filter method to create a new array of even numbers, and then use the reduce method to calculate the sum:

```ts
const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter((num: number) => num % 2 === 0);
const sumOfEvenNumbers = evenNumbers.reduce((acc: number, num: number) => acc + num);
console.log(sumOfEvenNumbers); //6
```

This code is easier to read and understand because it separates the filtering and reducing steps into two separate operations.
