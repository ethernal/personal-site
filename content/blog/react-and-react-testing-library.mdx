---
title: React Testing Library introduction
abstract: 'React Testing Library (RTL) is a popular testing utility for React applications that allows developers to test their components in a way that closely resembles how users interact with them. RTL provides a set of utilities that allow you to query the DOM for elements and interact with them in your tests.'
publishedOn: '2023-09-01'
---

_**Note:** This article was generated by ChatGPT. It's basically a modern take on Lorem Ipsum._

React Testing Library (RTL) is a popular testing utility for React applications that allows developers to test their components in a way that closely resembles how users interact with them. RTL provides a set of utilities that allow you to query the DOM for elements and interact with them in your tests.

Here’s an example of how to use RTL to test a simple React component in TypeScript:

```ts
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import MyComponent from './MyComponent';

describe('MyComponent', () => {
  it('renders the component', () => {
    render(<MyComponent />);
    const linkElement = screen.getByText(/hello world/i);
    expect(linkElement).toBeInTheDocument();
  });

  it('handles button click', () => {
    const handleClick = jest.fn();
    render(<MyComponent onClick={handleClick} />);
    const buttonElement = screen.getByRole('button');
    userEvent.click(buttonElement);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

In this example, we’re testing a simple component called MyComponent that renders a button and some text. The first test checks that the component renders correctly by searching for the text “hello world” using `screen.getByText()`. The second test checks that the onClick handler is called when the button is clicked by simulating a click event using `userEvent.click()` and checking that the handler function is called using `jest.fn()`.

Here are some advanced examples of how to use RTL to test more complex React components:

Testing asynchronous code: You can use RTL to test asynchronous code by using the `waitFor()` utility. For example, you can test that an element appears after an API call completes:

```ts
import { render, screen, waitFor } from '@testing-library/react';
import MyComponent from './MyComponent';

describe('MyComponent', () => {
  it('renders data from API', async () => {
    render(<MyComponent />);
    await waitFor(() => screen.getByText(/data loaded/i));
    const dataElement = screen.getByText(/data loaded/i);
    expect(dataElement).toBeInTheDocument();
  });
});
```

In this example, we’re testing that data is loaded from an API and rendered in the component. We use `waitFor()` to wait for the data to load before checking that it’s rendered correctly using `screen.getByText()`.

Testing with mocks: You can use RTL to test components that depend on external dependencies by mocking those dependencies. For example, you can test a component that depends on an API call:

```ts
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import MyComponent from './MyComponent';
import { getApiData } from './api';

jest.mock('./api');

describe('MyComponent', () => {
  it('renders data from API', async () => {
    getApiData.mockResolvedValueOnce({ data: 'test data' });
    render(<MyComponent />);
    const buttonElement = screen.getByRole('button');
    userEvent.click(buttonElement);
    const dataElement = await screen.findByText(/test data/i);
    expect(dataElement).toBeInTheDocument();
  });
});
```

In this example, we’re testing a component that depends on an API call. We mock the API call using `jest.mock()` and `getApiData.mockResolvedValueOnce()`. We then simulate a button click using userEvent.click() and wait for the data to be rendered using `screen.findByText()`.

## Mocking

`jest.mock()` is a method provided by the Jest testing framework that allows you to mock modules and dependencies in your tests. This can be useful when you want to isolate a component or module from its dependencies and test it in isolation.

In React Testing Library (RTL), you can use `jest.mock()` to mock dependencies that are used by your components. For example, you can mock an API call that your component depends on:

```ts
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import MyComponent from './MyComponent';
import { getApiData } from './api';

jest.mock('./api');

describe('MyComponent', () => {
  it('renders data from API', async () => {
    getApiData.mockResolvedValueOnce({ data: 'test data' });
    render(<MyComponent />);
    const buttonElement = screen.getByRole('button');
    userEvent.click(buttonElement);
    const dataElement = await screen.findByText(/test data/i);
    expect(dataElement).toBeInTheDocument();
  });
});
```

In this example, we’re testing a component that depends on an API call. We mock the API call using `jest.mock()` and `getApiData.mockResolvedValueOnce()`. We then simulate a button click using userEvent.click() and wait for the data to be rendered using `screen.findByText()`.

`jest.mock()` can also be used to mock modules that are imported by your components. For example, you can mock a utility function that your component depends on:

```ts
import { render, screen } from '@testing-library/react';
import MyComponent from './MyComponent';
import { myUtilityFunction } from './utils';

jest.mock('./utils');

describe('MyComponent', () => {
  it('renders the component', () => {
    myUtilityFunction.mockReturnValueOnce('test value');
    render(<MyComponent />);
    const linkElement = screen.getByText(/test value/i);
    expect(linkElement).toBeInTheDocument();
  });
});
```

In this example, we’re testing a component that depends on a utility function. We mock the utility function using `jest.mock()` and `myUtilityFunction.mockReturnValueOnce()`. We then check that the component renders correctly using `screen.getByText()`.
