---
title: Design system with TailwindCSS for Next.js
author: Sebastian Pieczy≈Ñski
date: 2023-10-28
published: false
keywords: [nextjs, design system, tailwind, css]
abstract: 'How to prevent content flashing and improve developer experience when creating templates for Next.js using Tailwind and CSS'
---

When designing this website the thing that has changed the most and took longest to get right was the design system. At the time of writing I am very happy with the solution and I would like to give to share with you what I learned and how it's implemented. Side benefit is that content flashing will not happen when using it and there is no need to use any smart code or hacks to achieve it!

## In the beginning...

There was a developer and there was a black IDE. IDE was empty and only the cursor was pulsing slowly. After a time a developer started to write code. The cursor was moving and the IDE was filled with code. The developer was happy it was good to move forward, pixels were drawn on the screen. After a while it all went wrong.. variables were all over the place with names as they saw fit at the time, paddings and margins were not uniform and changing color required editing each place separately. It was a mess and developer was sad.

The purge was needed.

...

If that short story reminds you of a thing or two then as you can clearly see you are not alone. Working with designers and having defined the details of how things are supposed to work helps a lot. If it's a solo project that has no defined structure yet then, well sometimes it leaks.

Thankfully I was already using TailwindCSS (it's awesome!) and there is documentation showing how to use CSS variables with Tailwind classes: see [how to use variables with Tailwind](https://tailwindcss.com/docs/variables) and especially how to define colors to be fully usable the same way as "native" Tailwind classes: see [how to define colors](https://tailwindcss.com/docs/customizing-colors).

It requires us to define the variable in the `:root` element and then we can use it in the `tailwind.config.ts`.

```globals.css
  --theme-gap-card: 2rem;
  --theme-padding-default: 2rem;
  --theme-radius-default: 6px;

  --theme-mute-factor: 0.4;

  /* COLORS */
  /* Light */
  --theme-light-color-primary: 80deg 90% 30%;

  --theme-light-foreground-light: 50deg 10% 10%;
  --theme-light-foreground-dark: 50deg 0% 0%;

  --theme-light-background-primary: 50deg 10% 90%;
  --theme-light-background-secondary: 50deg 20% 80%;

  /* Dark */

  --theme-dark-color-primary: 220deg 90% 20%;

  --theme-dark-foreground-light: 230deg 95% 95%;
  --theme-dark-foreground-dark: 230deg 45% 5%;

  --theme-dark-background-primary: 230deg 45% 4%;
  --theme-dark-background-secondary: 225deg 35% 15%;

  --theme-dark-foreground-primary: 220deg 100% 100%;

  --theme-accent: 12 80% 43%;
```

And then we can use these variables to create classes in Tailwind.

```tailwind.config.ts
theme: {
		extend: {
      borderRadius: {
        'theme-default': 'var(--theme-radius-default)',
      },
      /* ,,, */
      colors: {
        'theme-dark-background-primary':
        'hsl(var(--theme-dark-background-primary) / <alpha-value>)',
        'theme-dark-background-primary-muted':
        'hsl(var(--theme-dark-background-primary) / var(--theme-mute-factor))',
      },
    }
}
```

By defining only the values for `hsl(...)` CSS function we can now use the tailwinds `<alpha-value>` placeholder and use the class like this:

```html
<div class="bg-theme-light-background-primary/10">
  <!-- ... -->
</div>
```

If we defined the CSS variable with as a full `hsl` function we would have lost the ability to control the alpha channel and the code above would not work.

## Configuring Dark Mode in Tailwind

Configuring "Dark Mode" in Tailwind is pretty easy:

First we need to setup how dark mode should be handled by Tailwind itself. For Next.js I have found that using the `class` method is the most optimal way as it integrates well with other solutions and will prevent content flashing since the layout will be server side rendered.

```tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: 'class',
  content: [
    //...
	],
  //...
}
```

Now whenever we want to see dark mode CSS applied via Tailwind we only need to toggle `dark` class on the `html` element.

```tsx
<p className="text-slate-900 dark:text-slate-50">Hello World</p>
```

If the class on `html` element is set to 'dark' now the text will be white and black if not.

Slightly more involving is handling the actual change and saving of the styles.

## Creating ThemeContext and Provider

There are two main parts of the functionality we need to handle:

1. Storing the user preferences.
2. Sharing the preferred setting.

To keep user preferences regarding the theme we will use local storage Local storage is a kind of key-value pair database but in the browser and it fits our purpose perfectly as it stays with the user and is under his or hers control.

Sharing the user setting will require to share it on the client and on the server.

To store the theme for the client (browser) we will use Context. In React we create Context when we want to share a property between components without prop-drilling (passing it down manually to all components).

### Creating ThemeContext

#### Designing the API for the component with Typescript

I'll start slowly and explain crucial parts of the code, if you are familliar with the pattern you can scroll below to see the full source code.

To create new Context (and you can have many in your application) we use `createContext` function provided by React.

Let's think what we need our Context to be and what to provide:
1. we need to know what theme is currently selected and...
2. we need to be able to change the theme.

So our Context will need to keep both `theme` variable (that can be set to `light` or `dark`) and `setTheme` function to manipulate the `theme`. Knowing that let's name give it a name of `ThemeContext` and strongly type it:

```tsx
type ThemeContext = {
	theme: ColorThemeType;
	setTheme: React.Dispatch<React.SetStateAction<ColorThemeType>>;
};
```

To keep the `theme` variable in check we'll limit it's values to `light` and `dark` with the following type:

```ts
type ColorThemeType = 'light' | 'dark';
```

That way it will only be able to be set to predefined values when using Typescript.

####

Now that we have design of our function we can start coding it.

```tsx
const ThemeContext = createContext<ThemeContext | null>(null);
```

This will create new Context (think of it as an external slot or bucket for variables, outside of the components tree) and assign it value of `null` (more on this in a second).

Context itself **MUST** be created **OUTSIDE** of the component so it's not part of the Provider we will be using now.

I've decided to name it `Theme` but you will see components like this named `ThemeProvider` or similar more often to indicate they are utilizing context API.

```tsx
function Theme({ initialTheme = 'light', children }: ThemeProps) {
	const [theme, setTheme] = useState<ColorThemeType>(initialTheme);

	return (
		<ThemeContext.Provider value={{ theme, setTheme }}>
			{children}
		</ThemeContext.Provider>
	);
}
```

You can see that we are allowing to set the `initialTheme` and just in case the value is not provided we are setting it to `light` by default.

// TODO: finished here


```ThemeContext.tsx
'use client';
import React, { createContext, ReactNode, useContext, useState } from 'react';

import ColorThemeType from '@/types/ColorThemeType';

type ThemeContext = {
	theme: ColorThemeType;
	setTheme: React.Dispatch<React.SetStateAction<ColorThemeType>>;
};

type ThemeProps = {
	initialTheme: ColorThemeType;
	children: ReactNode;
};

const ThemeContext = createContext<ThemeContext | null>(null);

function Theme({ initialTheme = 'light', children }: ThemeProps) {
	const [theme, setTheme] = useState<ColorThemeType>(initialTheme);

	return (
		<ThemeContext.Provider value={{ theme, setTheme }}>
			{children}
		</ThemeContext.Provider>
	);
}

export function useThemeContext(): ThemeContext {
	const context = useContext(ThemeContext);

	if (context === undefined || context === null) {
		throw new Error('useThemeContext must be used within ThemeContextProvider');
	}

	return context;
}

export default Theme;
```


## Defining styles for Dark Mode

## Bonus - Using with NextUI

